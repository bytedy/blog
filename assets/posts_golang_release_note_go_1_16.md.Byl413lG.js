import{_ as s,o as a,c as i,a7 as e}from"./chunks/framework.C5t9huuP.js";const _=JSON.parse('{"title":"Go 1.16 新特性","description":"","frontmatter":{"title":"Go 1.16 新特性","date":"2024-08-09T20:00:00.000Z","hidden":true,"categories":["GO"]},"headers":[],"relativePath":"posts/golang/release_note/go_1_16.md","filePath":"posts/golang/release_note/go_1_16.md","lastUpdated":1724660638000}'),n={name:"posts/golang/release_note/go_1_16.md"},t=e(`<h1 id="go-1-16-新特性-go-embed" tabindex="-1">Go 1.16 新特性：Go embed <a class="header-anchor" href="#go-1-16-新特性-go-embed" aria-label="Permalink to &quot;Go 1.16 新特性：Go embed&quot;">​</a></h1><p>在以前，很多从其他语言转过来 Go 语言的同学会问到，或是踩到一个坑。就是以为 Go 语言所打包的二进制文件中会包含配置文件的联同编译和打包。</p><p>结果往往一把二进制文件挪来挪去，就无法把应用程序运行起来了。因为无法读取到静态文件的资源。</p><p>无法将静态资源编译打包进二进制文件的话，通常会有两种解决方法：</p><ul><li>第一种是识别这类静态资源，是否需要跟着程序走。</li><li>第二种就是考虑将其打包进二进制文件中。</li></ul><p>第二种情况的话，Go 以前是不支持的，大家就会去借助各种花式的开源库，例如：go-bindata/go-bindata 来实现。</p><p>但从在 Go1.16 起，Go 语言自身正式支持了该项特性，通过这篇文章快速了解和学习这项特性。</p><div class="language-Go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _ </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">embed</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//go:embed hello.txt</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">string</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 结果</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Hello</span></span></code></pre></div><p>注解的格式很简单，就是 <code>go:embed</code> 指令声明，外加读取的内容的地址，可支持相对和绝对路径。</p>`,9),p=[t];function l(o,h,d,k,r,g){return a(),i("div",{"data-pagefind-body":!0},p)}const E=s(n,[["render",l]]);export{_ as __pageData,E as default};
